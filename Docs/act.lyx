#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrartcl
\use_default_options true
\begin_modules
theorems-ams
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
ACT
\end_layout

\begin_layout Subtitle
ADC Characterization Toolkit
\end_layout

\begin_layout Author
Federico Asara
\begin_inset Newline newline
\end_inset

Juan David Gonzalez Cobas
\end_layout

\begin_layout Abstract
In this document I will provide a brief introduction to ADCs and their performan
ce parameters, along with the procedures to calculate them.
 
\end_layout

\begin_layout Abstract
Then I will present you ACT, the ADC Characterization Toolkit, a Python-powered
 application to evaluate the performances of ADCs.
 The goal of this tool is to work with three different kind of signals:
 a single sinusoidal wave, to evaluate static and dynamic parameters; two
 sinusoids with very close frequencies, to evaluate the intermodal distortion;
 sinusoidal wave with frequency sweep, to evaluate the ADC frequency response.
\end_layout

\begin_layout Section
Brief introduction to ADCs
\end_layout

\begin_layout Standard
Analog-to-digital converters, in short ADCs, are electronic devices which
 translate analog quantities in digital numbers.
 Usually analog input variables are converted by transducers into voltages
 or currents.
 An ADC is defined by three parameters:
\end_layout

\begin_layout Description
N the number of bits used to store each sample;
\end_layout

\begin_layout Description
FSR Full Scale Range, range of the analog values that can be represented
 by the device;
\end_layout

\begin_layout Description
LSB Least Significant Bit, is the minimum change in the input that guarantees
 a change in the output, defined as 
\begin_inset Formula 
\begin{equation}
LSB=\frac{FSR}{2^{N}}\label{eq:LSBdef}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The transfer function of an ADC shows the relation between the input and
 the output, and also shows the quantization error generated by the conversion.
 A transfer function of an ideal ADC is show in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Ideal-ADC-transfer"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/adc_ideal.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Ideal-ADC-transfer"

\end_inset

Ideal ADC transfer function
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Single Tone performance evaluation
\end_layout

\begin_layout Standard
In this mode the application will read a signal, be it from a file, synthetic
 or from an ADC, and will try to evaluate a bunch of parameters, assuming
 the data describes a sinewave.
 The algorithms will eliminate any incoherency during the performance evaluation
, will then determine the frequency of the sinewave and then will calculate
 
\end_layout

\begin_layout Subsubsection
Parameters explained
\end_layout

\begin_layout Standard
DNL stands for Differential Non Linearity, and it is defined as the difference
 between an actual step width of the transfer function and the LSB.
 An ideal ADC will thus have 
\begin_inset Formula 
\[
DNL_{i}=0\quad\forall i
\]

\end_inset

since every step is exactly 1 LSB.
 The DNL is defined as follow:
\begin_inset Formula 
\[
DNL_{i}=\frac{f(V_{x+1})-f(V_{x})}{LSB}-1\quad i\in]0,2^{N}-2[
\]

\end_inset

 
\end_layout

\begin_layout Remark
If the DNL respect the following condition:
\begin_inset Formula 
\[
DNL_{i}\leq1\, LSB\quad\forall i
\]

\end_inset


\end_layout

\begin_layout Remark
then the transfer function 
\begin_inset Formula $f(x)$
\end_inset

 is monotonic, with no missing codes.
\end_layout

\begin_layout Standard
INL, Integral Non Linearity, is described as the deviation, in LSB or as
 a FSR percentage, of an actual transfer function from a straight line.
 The INL error magnitude depends directly on the position chosen for this
 straight line.
 The theoretical formula of measuring INL is the following:
\begin_inset Formula 
\[
INL=\left|\frac{f(V_{x})-f(V_{0})}{LSB}-x\right|\quad i\in]0,2^{N}-1[
\]

\end_inset


\end_layout

\begin_layout Standard
The SNR, Signal to Noise Ratio, show how much a signal has been corrupted
 by noise.
 The theoretical value of the SNR is defined as follows:
\begin_inset Formula 
\[
SNR_{th}=6.02*N+1.76\quad[dB]
\]

\end_inset


\end_layout

\begin_layout Standard
The THD, Total Harmonic Distortion, is defined as the ratio of the signal
 to the RSS of a specified number of harmonics of the fundamental signal.
 IEEE Std.
 1241-2000 suggests to use the first 10 harmonics.
 A THD rating < 1% is desired.
 
\begin_inset Formula 
\[
THD_{n}=10\log\left(\sum_{i=2}^{n}10^{\left[\frac{h_{i}}{20}\right]^{2}}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $h_{i}$
\end_inset

 is the i-th harmonic expressed in dB.
\end_layout

\begin_layout Subsection
Two Tone Intermodulation Distortion evaluation
\end_layout

\begin_layout Standard
The application will read a signal from a source that is supposed to represent
 two sinewaves with a very small difference between their frequencies.
 If the ADC introduces harmonic distortions, these will be close to the
 signal; these interferences cannot be easily eliminated by a filter.
\end_layout

\begin_layout Subsection
Frequency Sweep evaluation
\end_layout

\begin_layout Standard
This test mode is by far the most complete and complicated of all.
 The application will control directly both a waveform generator (it could
 also be a DAC) and the ADC being tested.
 The idea is to generate a sinewave with a constant amplitude and change
 its frequency in a defined range, using a certain succession of steps.
 
\end_layout

\begin_layout Section
Parameters evaluation formulae and algorithms 
\end_layout

\begin_layout Subsection
Incoherent sampling
\end_layout

\begin_layout Standard
The biggest 
\emph on
problem
\emph default
 we have to account for when evaluating performances of an ADC is incoherent
 sampling: a sampling is incoherent if
\begin_inset Formula 
\[
\frac{f_{s}}{f_{0}}\notin\mathbb{N}
\]

\end_inset


\end_layout

\begin_layout Standard
Incoherency in sampling will produce the so-called spectral leakage; 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:spectral_leakage"

\end_inset

 shows how an incoherently sampled sine-wave suffers from spectral leakage:
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
http://gaussianwaves.blogspot.com/2011/01/fft-and-spectral-leakage.html
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/sineWave_FFT_spectral_leakage.png
	width 100text%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:spectral_leakage"

\end_inset

Spectral leakage of an incoherently sampled sine-wave
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since it interferes with all our formulae, we must find a way to 
\emph on
artificially remove
\emph default
 it.
 The best way so far only works assuming that we have a single tone signal
 
\begin_inset Formula $x[n]$
\end_inset

.
 
\end_layout

\begin_layout Standard
First of all we compute the DFT:
\begin_inset Formula 
\[
X[f]=DFT\left\{ x[n]\right\} 
\]

\end_inset

and then we compute:
\begin_inset Formula 
\begin{equation}
\alpha_{1}=\arg\max\left|X[f]\right|\label{eq:alpha1}
\end{equation}

\end_inset

and:
\begin_inset Formula 
\begin{equation}
\alpha_{2}=\begin{cases}
\alpha_{1}+1 & \left|X[\alpha_{1}+1]\right|\geq\left|X[\alpha_{1}-1]\right|\\
\alpha_{1}-1 & otherwise
\end{cases}\label{eq:alpha2}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\alpha_{1}$
\end_inset

 is the index of the highest peak in 
\begin_inset Formula $\left|X[f]\right|$
\end_inset

, and 
\begin_inset Formula $\alpha_{2}$
\end_inset

 is its follower.
 From these values we can compute the strength of the incoherency:
\begin_inset Formula 
\begin{equation}
\beta=\frac{M}{\pi}\arctan\left(\frac{\sin\frac{\pi}{M}}{\cos\frac{\pi}{M}+\frac{X[\alpha_{1}]}{X[\alpha_{2}]}}\right)\label{eq:beta}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The peak lies between 
\begin_inset Formula $\alpha_{1}$
\end_inset

 and 
\begin_inset Formula $\alpha_{2}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\alpha=\alpha_{1}+\beta\label{eq:alpha}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
We can then use 
\begin_inset Formula $\alpha$
\end_inset

 as the initial frequency guess for the sinefit4 algorithm, obtaining 
\begin_inset Formula $\bar{\omega_{0}}$
\end_inset

.
 Then:
\begin_inset Formula 
\begin{equation}
\alpha_{0}=\frac{\bar{\omega_{0}}}{\omega_{s}}M\label{eq:alpha0}
\end{equation}

\end_inset

is an improvement over 
\begin_inset Formula $\alpha$
\end_inset

.
 We can then use this to trim 
\begin_inset Formula $x[n]$
\end_inset

:
\begin_inset Formula 
\begin{equation}
x_{c}[n]=x[n]\quad\forall n=0..i\label{eq:trim}
\end{equation}

\end_inset

where:
\begin_inset Formula 
\[
i=\left\lfloor 0.5+M\frac{\left\lfloor \alpha_{0}\right\rfloor }{\alpha_{0}}\right\rfloor 
\]

\end_inset


\end_layout

\begin_layout Standard
We can use 
\begin_inset Formula $x_{c}[n]$
\end_inset

 to compute all the other parameters; from now on we will refer to 
\begin_inset Formula $x[n]$
\end_inset

 as a coherently sampled signal, unless otherwise specified.
\end_layout

\begin_layout Subsection
Histograms
\end_layout

\begin_layout Standard
In order to compute DNL and INL in a fast way for a given signal we generate
 two histograms that count the frequency of all the possible value the ADC
 can output.
 The 
\series bold
real histogram
\series default
 uses the data read from the signal, the 
\series bold
ideal histogram
\series default
 uses simulated data for the same signal supposing we have a perfect ADC.
 The signal used in this case is a sinusoid.
\end_layout

\begin_layout Standard
The histogram should theoretically have 
\begin_inset Formula $R_{t}=2^{N}$
\end_inset

 bars: for high N values, however, we will have to many bins, slowing down
 the computation.
 We fix a resolution limit 
\begin_inset Formula $R_{l}$
\end_inset

 such that we have:
\begin_inset Formula 
\begin{equation}
R=\min\text{\left(R_{l},R_{t}\right)}\label{eq:histres}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
A good value of 
\begin_inset Formula $R_{l}$
\end_inset

 could easily be 256 or 512, and it should preferably be a power of two.
\end_layout

\begin_layout Subsubsection
Ideal histogram generation
\end_layout

\begin_layout Standard
To generate the ideal histogram we need few information:
\end_layout

\begin_layout Itemize
the resolution 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Itemize
the number of samples M
\end_layout

\begin_layout Itemize
the first and last values of the signal, 
\begin_inset Formula $x[0]$
\end_inset

 and 
\begin_inset Formula $x[M-1]$
\end_inset


\end_layout

\begin_layout Standard
We can then evaluate:
\begin_inset Formula 
\[
\phi=\sin\left(\frac{\pi}{2}\frac{M}{M+x[0]+x[M-1]}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
which will keep the ideal sinusoid we are simulating just below the full
 scale.
 We can then define the value of each bar:
\begin_inset Formula 
\[
h_{i}[n]=\frac{M}{\pi}\left(\arcsin\frac{n-\frac{R}{2}}{\frac{R}{2}}-\arcsin\frac{n-1-\frac{R}{2}}{\frac{R}{2}}\right)\quad\forall n\in[0,\, R-1]
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Real histogram generation
\end_layout

\begin_layout Standard
To generate the real histogram
\begin_inset Formula 
\[
h_{r}[n]\quad\forall n\in[0,\, R-1]
\]

\end_inset

no particular method is needed.
 For example, 
\emph on
numpy 
\emph default
provides the 
\emph on
hist
\emph default
 function, that calculate an histogram of an array with a given number of
 bins.
 
\end_layout

\begin_layout Subsection
Non linearities
\end_layout

\begin_layout Standard
We use histograms when evaluating DNL and INL in order to speed up the calculati
on.
\end_layout

\begin_layout Subsubsection
DNL
\end_layout

\begin_layout Standard
We can easily compute an histogram of the DNL provided we have the ideal
 and real histograms:
\begin_inset Formula 
\[
DNL[n]=\frac{H_{r}[n]}{H_{i}[n]}-1
\]

\end_inset


\end_layout

\begin_layout Subsubsection
INL
\end_layout

\begin_layout Standard
The INL is evaluated from the DNL:
\begin_inset Formula 
\[
INL[n]=\sum_{i=0}^{n}DNL[i]
\]

\end_inset


\end_layout

\begin_layout Subsection
Sinusoidal wave frequency detection
\end_layout

\begin_layout Standard
In order to compute the SNR of a single tone signal, we need to know the
 wave's parameters.
 IEEE proposes two different ways to solve this problem, whether we know
 or not the wave's frequency.
\end_layout

\begin_layout Standard
A wave can represented as a superposition of two waves and a constant term,
 using five parameters:
\begin_inset Formula 
\[
A\cos\left(\omega_{0}t+\theta\right)+B\sin\left(\omega_{0}t+\theta\right)+C
\]

\end_inset


\end_layout

\begin_layout Standard
The amplitude and the phase of the frequency can then be evaluated this
 way:
\begin_inset Formula 
\begin{eqnarray*}
V & = & \sqrt{A^{2}+B^{2}}\\
\theta & = & \arctan\frac{B}{A}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Subsubsection
sinefit3
\end_layout

\begin_layout Standard
This algorithm evaluates A, B, C starting from 
\begin_inset Formula $\omega$
\end_inset

.
 The algorithm is well described in --INSERT BIBLIOGRAPHY HERE--.
\end_layout

\begin_layout Subsubsection
sinefit4
\end_layout

\begin_layout Standard
This algorithm evaluates A, B, C and 
\begin_inset Formula $\omega_{0}$
\end_inset

 starting for an initial approximation of the angular frequency.
 A good approximation is given by this formula:
\begin_inset Formula 
\[
\omega_{i}=2\pi\frac{f_{s}}{M}arg\max_{j}X_{j}
\]

\end_inset

where 
\begin_inset Formula $X_{j}$
\end_inset

 is the DFT of the signal, 
\begin_inset Formula $f_{s}$
\end_inset

 the sampling frequency and 
\begin_inset Formula $M$
\end_inset

 the number of samples of the signal.
 Based on sinefit3, this algorithm is essentially a least square fit of
 the four parameters, and it's well described in --INSERT BIBLIOGRAPHY HERE--.
 
\end_layout

\begin_layout Subsection
Performance parameters
\end_layout

\begin_layout Standard
All these parameters are calculated for a digitized sinusoidal wave, eventually
 multiplied with a window signal.
\end_layout

\begin_layout Subsubsection
SNR: Signal to Noise Ratio
\end_layout

\begin_layout Standard
The SNR is a rather important parameter, and its general formula is the
 following:
\begin_inset Formula 
\[
SNR=20\log_{10}\frac{P_{s}}{P_{n}}\quad[dB]
\]

\end_inset

with 
\begin_inset Formula $P_{s}$
\end_inset

 being the signal power and 
\begin_inset Formula $P_{n}$
\end_inset

 the noise power
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
It doesn't take into account the harmonic distortions, in addition to DC
 and the meaningful signal.
\end_layout

\end_inset

.
 This ratio will always be greater than one.
 The noise power is computed this way:
\begin_inset Formula 
\begin{eqnarray*}
C[f] & = & \begin{cases}
0 & f\in\{0,\, i\alpha_{0},\, M-1-\alpha_{0}\}\quad\forall i\in[0,\left\lfloor \frac{M}{\alpha_{0}}\right\rfloor ]\\
X[f] & otherwise
\end{cases}\\
P_{n} & = & \frac{\sum C[f]^{2}}{M}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Subsubsection
SINAD: SIgnal to Noise And Distortion ratio
\end_layout

\begin_layout Standard
To compute with great precision this value, we compare our wave with a synthetic
 one.
 Using the data obtained from sinefit4 we can generate a signal that represents
 with great precision (as a perfect ADC) the sinusoid, so we can compute
 the noise signal:
\begin_inset Formula 
\begin{eqnarray*}
s[k] & = & C+A\cos(\frac{\omega_{0}}{f_{s}}k)+B\sin(\frac{\omega_{0}}{f_{s}}k)\,\,\forall k\in[0,\, M[\\
n[k] & = & x[k]-n[k]
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
At this point we calculate:
\begin_inset Formula 
\begin{eqnarray*}
RMS_{n} & = & \sqrt{\frac{1}{M}\sum_{i=0}^{M-1}n[k]^{2}}\\
RMS_{x} & = & \frac{\max x}{\sqrt{2}}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
And then we can define the SINAD:
\begin_inset Formula 
\[
SINAD=20\log_{10}\frac{RMS_{x}}{RMS_{n}}\;[dB]
\]

\end_inset


\end_layout

\begin_layout Subsubsection
THD: Total Harmonic Distortion
\end_layout

\begin_layout Standard
The THS is evaluated in the following way:
\begin_inset Formula 
\[
THD=-20\log_{10}\frac{X[\alpha_{0}]}{\left\Vert h_{i}\right\Vert }
\]

\end_inset


\end_layout

\begin_layout Standard
where:
\begin_inset Formula 
\begin{eqnarray*}
\alpha_{0} & = & \arg\max X[f]\\
h_{i} & = & X[\alpha_{0}i]\quad\forall i\in[2,\,2-i[
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Subsubsection
ENOB: Effective Number Of Bits
\end_layout

\begin_layout Standard
Let's define the full scale range as:
\begin_inset Formula 
\[
R_{FS}=2^{N-1}
\]

\end_inset


\end_layout

\begin_layout Standard
The data range, instead, is the following quantity:
\begin_inset Formula 
\[
R_{data}=\frac{\min x[t]+\max x[t]}{2}
\]

\end_inset


\end_layout

\begin_layout Standard
Therefore, we define 
\begin_inset Formula $f$
\end_inset

 as follow:
\begin_inset Formula 
\[
f=20log\frac{R_{FS}}{R_{data}}
\]

\end_inset

in order to avoid penalization for a signal that doesn't cover all the full
 scale range.
 The effective number of bits can then be defined as:
\begin_inset Formula 
\[
ENOB=\frac{SINAD+f-1.76}{6.02}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
SFDR: Spurious Free Dynamic Range
\end_layout

\begin_layout Standard
The spurious free dynamic range is, simply put, the difference between the
 main peak and the highest harmonic distortion peak in dBc:
\begin_inset Formula 
\[
SFDR_{i}=10\log\frac{\max X[f]}{\max h_{i}}
\]

\end_inset

A good value of 
\begin_inset Formula $i$
\end_inset

 is 10.
 
\end_layout

\begin_layout Section
PAGE: Python ADC and Generators API
\end_layout

\begin_layout Standard
The PAGE API offers a Pyhton interface to control both ADC and generators;
 a generator could be a waveform generator, like the Agilent 33250A, or
 a DAC.
 
\end_layout

\begin_layout Subsection
Generators
\end_layout

\begin_layout Standard
A Generator is a device that outputs analog data following some specifications,
 or from a digital signal.
 All the generator should be able to produce a sinewave with a predefined
 amplitude, frequency and DC component.
 This allows us to implement  
\end_layout

\begin_layout Section
ACT: ADC Characterization Toolkit
\end_layout

\begin_layout Standard
When using this mode, the program will analyze data read either from an
 ADC or a file.
 The application only support files at the day of writing.
 
\end_layout

\begin_layout Subsection
Single tone mode
\end_layout

\begin_layout Standard
The data supplied to the application is the digitization of a sinusoidal
 wave.
 The file structure is rather easy, and contains all the information we
 need to compute everything:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[SIGNAL]
\end_layout

\begin_layout Plain Layout

nbits = n
\end_layout

\begin_layout Plain Layout

rate = Fs
\end_layout

\begin_layout Plain Layout

data =<tab>data[0]
\end_layout

\begin_layout Plain Layout

<tab>data[1]
\end_layout

\begin_layout Plain Layout

..
\end_layout

\begin_layout Plain Layout

<tab>data[M -1]
\end_layout

\end_inset


\end_layout

\begin_layout Description
n number of bits of the ADC;
\end_layout

\begin_layout Description
Fs sampling rate;
\end_layout

\begin_layout Description
data a list of integers that represent the signal, always preceded by a
 TAB character.
 
\end_layout

\end_body
\end_document
